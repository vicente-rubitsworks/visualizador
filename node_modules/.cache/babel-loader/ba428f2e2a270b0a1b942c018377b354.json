{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { isFunction } from './util/isFunction';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\n\nvar Subscriber = function (_super) {\n  __extends(Subscriber, _super);\n\n  function Subscriber(destination) {\n    var _this = _super.call(this) || this;\n\n    _this.isStopped = false;\n\n    if (destination) {\n      _this.destination = destination;\n\n      if (isSubscription(destination)) {\n        destination.add(_this);\n      }\n    } else {\n      _this.destination = EMPTY_OBSERVER;\n    }\n\n    return _this;\n  }\n\n  Subscriber.create = function (next, error, complete) {\n    return new SafeSubscriber(next, error, complete);\n  };\n\n  Subscriber.prototype.next = function (value) {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value);\n    }\n  };\n\n  Subscriber.prototype.error = function (err) {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n\n      this._error(err);\n    }\n  };\n\n  Subscriber.prototype.complete = function () {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n\n      this._complete();\n    }\n  };\n\n  Subscriber.prototype.unsubscribe = function () {\n    if (!this.closed) {\n      this.isStopped = true;\n\n      _super.prototype.unsubscribe.call(this);\n\n      this.destination = null;\n    }\n  };\n\n  Subscriber.prototype._next = function (value) {\n    this.destination.next(value);\n  };\n\n  Subscriber.prototype._error = function (err) {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  };\n\n  Subscriber.prototype._complete = function () {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  };\n\n  return Subscriber;\n}(Subscription);\n\nexport { Subscriber };\nvar _bind = Function.prototype.bind;\n\nfunction bind(fn, thisArg) {\n  return _bind.call(fn, thisArg);\n}\n\nvar ConsumerObserver = function () {\n  function ConsumerObserver(partialObserver) {\n    this.partialObserver = partialObserver;\n  }\n\n  ConsumerObserver.prototype.next = function (value) {\n    var partialObserver = this.partialObserver;\n\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  };\n\n  ConsumerObserver.prototype.error = function (err) {\n    var partialObserver = this.partialObserver;\n\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  };\n\n  ConsumerObserver.prototype.complete = function () {\n    var partialObserver = this.partialObserver;\n\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  };\n\n  return ConsumerObserver;\n}();\n\nvar SafeSubscriber = function (_super) {\n  __extends(SafeSubscriber, _super);\n\n  function SafeSubscriber(observerOrNext, error, complete) {\n    var _this = _super.call(this) || this;\n\n    var partialObserver;\n\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      partialObserver = {\n        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined,\n        error: error !== null && error !== void 0 ? error : undefined,\n        complete: complete !== null && complete !== void 0 ? complete : undefined\n      };\n    } else {\n      var context_1;\n\n      if (_this && config.useDeprecatedNextContext) {\n        context_1 = Object.create(observerOrNext);\n\n        context_1.unsubscribe = function () {\n          return _this.unsubscribe();\n        };\n\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context_1),\n          error: observerOrNext.error && bind(observerOrNext.error, context_1),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)\n        };\n      } else {\n        partialObserver = observerOrNext;\n      }\n    }\n\n    _this.destination = new ConsumerObserver(partialObserver);\n    return _this;\n  }\n\n  return SafeSubscriber;\n}(Subscriber);\n\nexport { SafeSubscriber };\n\nfunction handleUnhandledError(error) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    reportUnhandledError(error);\n  }\n}\n\nfunction defaultErrorHandler(err) {\n  throw err;\n}\n\nfunction handleStoppedNotification(notification, subscriber) {\n  var onStoppedNotification = config.onStoppedNotification;\n  onStoppedNotification && timeoutProvider.setTimeout(function () {\n    return onStoppedNotification(notification, subscriber);\n  });\n}\n\nexport var EMPTY_OBSERVER = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop\n};","map":{"version":3,"sources":["C:\\Users\\vicen\\Documents\\React\\visualizador\\node_modules\\rxjs\\src\\internal\\Subscriber.ts"],"names":[],"mappings":"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","sourcesContent":["import { isFunction } from './util/isFunction';\nimport { Observer, ObservableNotification } from './types';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param next The `next` callback of an Observer.\n   * @param error The `error` callback of an\n   * Observer.\n   * @param complete The `complete` callback of an\n   * Observer.\n   * @return A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   * @deprecated Do not use. Will be removed in v8. There is no replacement for this\n   * method, and there is no reason to be creating instances of `Subscriber` directly.\n   * If you have a specific use case, please file an issue.\n   */\n  static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T> {\n    return new SafeSubscriber(next, error, complete);\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected isStopped: boolean = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected destination: Subscriber<any> | Observer<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.\n   */\n  constructor(destination?: Subscriber<any> | Observer<any>) {\n    super();\n    if (destination) {\n      this.destination = destination;\n      // Automatically chain subscriptions together here.\n      // if destination is a Subscription, then it is a Subscriber.\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value!);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null!;\n    }\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n  protected _complete(): void {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n}\n\n/**\n * This bind is captured here because we want to be able to have\n * compatibility with monoid libraries that tend to use a method named\n * `bind`. In particular, a library called Monio requires this.\n */\nconst _bind = Function.prototype.bind;\n\nfunction bind<Fn extends (...args: any[]) => any>(fn: Fn, thisArg: any): Fn {\n  return _bind.call(fn, thisArg);\n}\n\n/**\n * Internal optimization only, DO NOT EXPOSE.\n * @internal\n */\nclass ConsumerObserver<T> implements Observer<T> {\n  constructor(private partialObserver: Partial<Observer<T>>) {}\n\n  next(value: T): void {\n    const { partialObserver } = this;\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n\n  error(err: any): void {\n    const { partialObserver } = this;\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  }\n\n  complete(): void {\n    const { partialObserver } = this;\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n}\n\nexport class SafeSubscriber<T> extends Subscriber<T> {\n  constructor(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((e?: any) => void) | null,\n    complete?: (() => void) | null\n  ) {\n    super();\n\n    let partialObserver: Partial<Observer<T>>;\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      // The first argument is a function, not an observer. The next\n      // two arguments *could* be observers, or they could be empty.\n      partialObserver = {\n        next: observerOrNext ?? undefined,\n        error: error ?? undefined,\n        complete: complete ?? undefined,\n      };\n    } else {\n      // The first argument is a partial observer.\n      let context: any;\n      if (this && config.useDeprecatedNextContext) {\n        // This is a deprecated path that made `this.unsubscribe()` available in\n        // next handler functions passed to subscribe. This only exists behind a flag\n        // now, as it is *very* slow.\n        context = Object.create(observerOrNext);\n        context.unsubscribe = () => this.unsubscribe();\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context),\n          error: observerOrNext.error && bind(observerOrNext.error, context),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n        };\n      } else {\n        // The \"normal\" path. Just use the partial observer directly.\n        partialObserver = observerOrNext;\n      }\n    }\n\n    // Wrap the partial observer to ensure it's a full observer, and\n    // make sure proper error handling is accounted for.\n    this.destination = new ConsumerObserver(partialObserver);\n  }\n}\n\nfunction handleUnhandledError(error: any) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    // Ideal path, we report this as an unhandled error,\n    // which is thrown on a new call stack.\n    reportUnhandledError(error);\n  }\n}\n\n/**\n * An error handler used when no error handler was supplied\n * to the SafeSubscriber -- meaning no error handler was supplied\n * do the `subscribe` call on our observable.\n * @param err The error to handle\n */\nfunction defaultErrorHandler(err: any) {\n  throw err;\n}\n\n/**\n * A handler for notifications that cannot be sent to a stopped subscriber.\n * @param notification The notification being sent\n * @param subscriber The stopped subscriber\n */\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\n  const { onStoppedNotification } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\n\n/**\n * The observer used as a stub for subscriptions where the user did not\n * pass any arguments to `subscribe`. Comes with the default error handling\n * behavior.\n */\nexport const EMPTY_OBSERVER: Readonly<Observer<any>> & { closed: true } = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop,\n};\n"]},"metadata":{},"sourceType":"module"}